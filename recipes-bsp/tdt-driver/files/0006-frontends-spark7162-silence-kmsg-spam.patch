From 5b7e0abddccc113705c233d736fdd6d3b89a5622 Mon Sep 17 00:00:00 2001
From: Stefan Seyfried <seife@tuxbox-git.slipkontur.de>
Date: Sun, 9 Sep 2012 12:48:48 +0200
Subject: [PATCH 6/6] frontends/spark7162: silence kmsg spam

---
 frontends/base/ix7306.c                            |   17 +++
 frontends/base/sharp5469c.c                        |    7 ++
 frontends/base/sharp6465.c                         |    8 ++
 frontends/base/sharp7803.c                         |    9 ++
 frontends/spark7162/D3501.c                        |  130 +++++++++++++++++++-
 frontends/spark7162/spark7162.c                    |    4 +
 frontends/spark7162/stv0367/D0367cab.c             |   13 ++
 frontends/spark7162/stv0367/D0367ter.c             |    7 ++
 .../spark7162/stv0367/stv0367qam/chip_0367qam.c    |    5 +
 frontends/spark7162/stv0367/stv0367qam/d0367_qam.c |    4 +
 .../spark7162/stv0367/stv0367ter/chip_0367ter.c    |    5 +
 11 files changed, 208 insertions(+), 1 deletion(-)

diff --git a/frontends/base/ix7306.c b/frontends/base/ix7306.c
index 2ac57c6..c32b321 100644
--- a/frontends/base/ix7306.c
+++ b/frontends/base/ix7306.c
@@ -25,6 +25,9 @@
 #include "dvb_frontend.h"
 #include "ix7306.h"
 
+extern int debug_fe7162;
+#define _DEBUG if (debug_fe7162)
+
 struct ix7306_state {
 	struct dvb_frontend		*fe;
 	struct i2c_adapter		*i2c;
@@ -57,11 +60,14 @@ static int ix7306_write(struct ix7306_state *state, u8 *buf, u8 len)
 	int i;
 	struct i2c_msg msg = { .addr = config->addr, .flags = 0, .buf = buf, .len = len };
 
+_DEBUG
+{
 	for (i = 0; i < len; i++)
 	{
 		printk("%02x ", buf[i]);
 	}
 	printk("\n");
+}
 
 	err = i2c_transfer(state->i2c, &msg, 1);
 	if (err != 1)
@@ -351,6 +357,7 @@ static int ix7306_set_freq(struct dvb_frontend *fe, u32 freq_KHz, u32 tuner_BW)
 {
 	u32			tuner_bw_K = tuner_BW/1000;
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 
 	memset(reg_data,0,sizeof(reg_data));
@@ -359,6 +366,7 @@ static int ix7306_set_freq(struct dvb_frontend *fe, u32 freq_KHz, u32 tuner_BW)
 	reg_data[3] = 0xe1;
 	reg_data[4] = 0x42;
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	tun_setfreq_QM1D1B0004(fe,freq_KHz,tuner_bw_K, &reg_data[0]);
 
@@ -371,11 +379,13 @@ static int ix7306_set_state(struct dvb_frontend *fe,
 {
 	struct ix7306_state *state = fe->tuner_priv;
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 
 	if (param & DVBFE_TUNER_FREQUENCY) {
 		state->frequency = tstate->frequency;
 		state->bandwidth = tstate->bandwidth;
+_DEBUG
 		printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 		ix7306_set_freq (fe, state->frequency, state->bandwidth);
 	} else {
@@ -424,11 +434,13 @@ static int ix7306_get_status(struct dvb_frontend *fe, u32 *status)
 	}
 
 	if (result[0] & 0x40) {
+_DEBUG
 		printk("%s: Tuner Phase Locked\n", __func__);
 		*status = 1;
 	}
 	else
 	{
+_DEBUG
 		printk("%s: Tuner Phase Not Locked result - 0x%x, 0x%x,\n", __func__, result[0], result[1]);
 	}
 
@@ -643,11 +655,13 @@ int ix7306_get_frequency(struct dvb_frontend *fe, u32 *frequency)
 	if (&fe->ops)
 		frontend_ops = &fe->ops;
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 
 	if (&frontend_ops->tuner_ops)
 		tuner_ops = &frontend_ops->tuner_ops;
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 
 	if (tuner_ops->get_state) {
@@ -656,6 +670,7 @@ int ix7306_get_frequency(struct dvb_frontend *fe, u32 *frequency)
 			return err;
 		}
 		*frequency = t_state.frequency;
+_DEBUG
 		printk("%s: Frequency=%d\n", __func__, t_state.frequency);
 	}
 	return 0;
@@ -683,6 +698,7 @@ int ix7306_set_frequency(struct dvb_frontend *fe, u32 frequency)
 			return err;
 		}
 	}
+_DEBUG
 	printk("%s: Frequency=%d\n", __func__, t_state.frequency);
 	return 0;
 }
@@ -716,6 +732,7 @@ int ix7306_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)
 		}
 		*bandwidth = t_state.bandwidth;
 	}
+_DEBUG
 	printk("%s: Bandwidth=%d\n", __func__, t_state.bandwidth);
 	return 0;
 }
diff --git a/frontends/base/sharp5469c.c b/frontends/base/sharp5469c.c
index 3fd2d08..1f71704 100644
--- a/frontends/base/sharp5469c.c
+++ b/frontends/base/sharp5469c.c
@@ -8,6 +8,9 @@
 #include "dvb_frontend.h"
 #include "sharp5469c.h"
 
+extern int debug_fe7162;
+#define _DEBUG if (debug_fe7162)
+
 struct sharp5469c_state {
 	struct dvb_frontend		*fe;
 	struct i2c_adapter		*i2c;
@@ -49,6 +52,7 @@ static int sharp5469c_write(struct sharp5469c_state *state, u8 *buf, u8 length)
 	const struct sharp5469c_config *config = state->config;
 	int err = 0;
 	struct i2c_msg msg = { .addr = config->addr, .flags = 0, .buf = buf, .len = length };
+_DEBUG
 	{
 		int i;
 		for (i = 0; i < length; i++)
@@ -84,6 +88,7 @@ static int sharp5469c_get_status(struct dvb_frontend *fe, u32 *status)
 
 	if (result[0] & 0x40)
 	{
+_DEBUG
 		printk(KERN_DEBUG "%s: Tuner Phase Locked\n", __func__);
 		*status = 1;
 	}
@@ -126,6 +131,7 @@ static	void sharp5469c_calculate_mop_divider(u32 freq, int *byte)
 	i64Freq += 5;
 	i64Freq /= 10;
 	data = (long)i64Freq;
+_DEBUG
 	printk(KERN_ERR "%s: data = %ld\n", __func__, data);
 	//data = (long)((freq + sharp5469c_calculate_mop_if())/sharp5469c_calculate_mop_step(byte) +0.5);
 	*(byte+1) = (int)((data>>8)&0x7F);		//byte2
@@ -280,6 +286,7 @@ static int sharp5469c_set_params(struct dvb_frontend* fe,
 			goto exit;
 	}
 	sharp5469c_get_status(fe, &status);
+_DEBUG
 	printk(KERN_ERR "%s: status = %d\n", __func__, status);
 
 	return 0;
diff --git a/frontends/base/sharp6465.c b/frontends/base/sharp6465.c
index d381e4c..016aa5b 100644
--- a/frontends/base/sharp6465.c
+++ b/frontends/base/sharp6465.c
@@ -8,6 +8,9 @@
 #include "dvb_frontend.h"
 #include "sharp6465.h"
 
+extern int debug_fe7162;
+#define _DEBUG if (debug_fe7162)
+
 struct sharp6465_state {
 	struct dvb_frontend		*fe;
 	struct i2c_adapter		*i2c;
@@ -47,6 +50,7 @@ static int sharp6465_write(struct sharp6465_state *state, u8 *buf, u8 length)
 	int err = 0;
 	struct i2c_msg msg = { .addr = config->addr, .flags = 0, .buf = buf, .len = length };
 
+_DEBUG
 	printk(KERN_ERR "%s: state->i2c=<%d>, config->addr = %d\n",
 			__func__, (int)state->i2c, config->addr);
 
@@ -74,6 +78,7 @@ static int sharp6465_get_status(struct dvb_frontend *fe, u32 *status)
 
 	if (result[0] & 0x40)
 	{
+_DEBUG
 		printk(KERN_DEBUG "%s: Tuner Phase Locked\n", __func__);
 		*status = 1;
 	}
@@ -117,6 +122,7 @@ static	void calculate_mop_divider(u32 freq, int *byte)
 	i64Freq += 5;
 	i64Freq /= 10;
 	data = (long)i64Freq;
+_DEBUG
 	printk(KERN_ERR "%s: data = %ld\n", __func__, data);
 	//data = (long)((freq + calculate_mop_if())/calculate_mop_step(byte) + 0.5);
 	*(byte+1) = (int)((data>>8)&0x7F);		//byte2
@@ -225,6 +231,7 @@ static int sharp6465_set_params(struct dvb_frontend* fe,
 	u32 f = params->frequency;
 	struct dvb_ofdm_parameters *op = &params->u.ofdm;
 
+_DEBUG
 	printk(KERN_ERR "%s: f = %d, bandwidth = %d\n", __func__, f, op->bandwidth);
 
 	tuner_SHARP6465_CalWrBuffer(f/1000,
@@ -255,6 +262,7 @@ static int sharp6465_set_params(struct dvb_frontend* fe,
 	if (fe->ops.i2c_gate_ctrl(fe, 1) < 0)
 		goto exit;
 	sharp6465_get_status(fe, &status);
+_DEBUG
 	printk(KERN_ERR "%s: status = %d\n", __func__, status);
 
 	return 0;
diff --git a/frontends/base/sharp7803.c b/frontends/base/sharp7803.c
index 39836be..aadb989 100644
--- a/frontends/base/sharp7803.c
+++ b/frontends/base/sharp7803.c
@@ -25,6 +25,9 @@
 #include "dvb_frontend.h"
 #include "sharp7803.h"
 
+extern int debug_fe7162;
+#define _DEBUG if (debug_fe7162)
+
 struct sharp7803_state {
 	struct dvb_frontend		*fe;
 	struct i2c_adapter		*i2c;
@@ -47,11 +50,14 @@ static int sharp7803_write(struct sharp7803_state *state, u8 reg, u8 *buf, u8 le
 	aBuf[0] = reg;
 	memcpy(&aBuf[1], buf, len);
 
+_DEBUG
+{
 	for (i = 0; i < len + 1; i++)
 	{
 		printk("%02x ", aBuf[i]);
 	}
 	printk("\n");
+}
 
 	err = i2c_transfer(state->i2c, &msg, 1);
 	if (err != 1)
@@ -97,11 +103,13 @@ static int sharp7803_get_status(struct dvb_frontend *fe, u32 *status)
 	}
 	if (result[0] & 0x40)
     {
+_DEBUG
 		printk("%s: Tuner Phase Locked\n", __func__);
 		*status = 1;
 	}
 	else
 	{
+_DEBUG
 		printk("%s: Tuner Phase Not Locked result - 0x%x, 0x%x,\n", __func__, result[0], result[1]);
 	}
 
@@ -300,6 +308,7 @@ static int sharp7803_init(struct dvb_frontend *fe)
 	mdelay(1);
     /*读tuner*/
     Error |= sharp7803_read(state, 0, &chip_id);
+_DEBUG
     printk("chip_id = %d\n", chip_id);
 
     // Write fixed value
diff --git a/frontends/spark7162/D3501.c b/frontends/spark7162/D3501.c
index d68f0c4..1acc650 100644
--- a/frontends/spark7162/D3501.c
+++ b/frontends/spark7162/D3501.c
@@ -175,6 +175,9 @@
 #include "D3501_ext.h"
 #include "D3501.h"
 
+extern int debug_fe7162;
+#define _DEBUG if (debug_fe7162)
+
 struct dvb_d3501_fe_state {
 	struct dvb_frontend frontend;
 	struct nim_device 	spark_nimdev;
@@ -1001,6 +1004,7 @@ static INT32 nim_s3501_open(struct nim_device *dev)
 	INT32 ret;
 	//struct nim_s3501_private *priv = (struct nim_s3501_private *) dev->priv;
 
+_DEBUG
 	printk("    Enter fuction nim_s3501_open\n");
 	nim_s3501_set_acq_workmode(dev, NIM_OPTR_HW_OPEN);
 
@@ -1858,6 +1862,7 @@ static INT32 nim_s3501_set_phase_noise(struct nim_device *dev)
 	};   // 0~3: per_ba~per_8a
 	UINT32 buf_index = 0;
 	struct nim_s3501_private *priv = (struct nim_s3501_private *) dev->priv;
+_DEBUG
 	printk("            Eenter function set_phase_noise\n");
 	sdat = 0xba;
 	nim_reg_write(dev, RB5_CR_PRS_TRA, &sdat, 1);
@@ -1881,6 +1886,7 @@ static INT32 nim_s3501_set_phase_noise(struct nim_device *dev)
 		nim_reg_read(dev, R76_BIT_ERR + 0x02, &verdata, 1);
 		if (verdata != data)
 		{
+_DEBUG
 			printk("!!! RESET BER ERROR!\n");
 		}
 		data = 0x80;
@@ -1888,6 +1894,7 @@ static INT32 nim_s3501_set_phase_noise(struct nim_device *dev)
 		nim_reg_read(dev, R79_PKT_ERR + 0x01, &verdata, 1);
 		if (verdata != data)
 		{
+_DEBUG
 			printk("!!! RESET PER ERROR!\n");
 		}
 		//comm_delay(100);
@@ -1896,6 +1903,7 @@ static INT32 nim_s3501_set_phase_noise(struct nim_device *dev)
 		nim_s3501_get_SNR(dev, &snr);
 		nim_s3501_get_new_BER(dev, &ber);
 		nim_s3501_get_new_PER(dev, &per);
+_DEBUG
 		printk("--- snr/ber/per = %d/%d/%d\n", snr, ber, per);
 
 		//  		if (per_buf[buf_index] < per)
@@ -1914,6 +1922,7 @@ static INT32 nim_s3501_set_phase_noise(struct nim_device *dev)
 	max_per = 0;
 	for (i = 0; i < buf_index; i++)
 	{
+_DEBUG
 		printk("per_buf[%d] = 0x%x\n", i, per_buf[i]);
 		per_buf[i] >>= 4;
 		if (per_buf[i] < per_buf[min_per])
@@ -1931,16 +1940,19 @@ static INT32 nim_s3501_set_phase_noise(struct nim_device *dev)
 	if (min_per <= max_per)
 	{
 		priv->t_Param.t_phase_noise_detected = 0;
+_DEBUG
 		printk("No phase noise detected!\n");
 	}
 	else
 	{
 		priv->t_Param.t_phase_noise_detected = 1;
+_DEBUG
 		printk("Phase noise detected!\n");
 		data = 0x42;
 		nim_reg_write(dev, R33_CR_CTRL + 0x04, &data, 1);
 	}
 
+_DEBUG
 	printk("min_per is %d, max_per is %d\n", min_per, max_per);
 	if ((min_per < buf_index - 1) && (per_buf[min_per] == per_buf[min_per + 1]))
 	{
@@ -1958,6 +1970,7 @@ static INT32 nim_s3501_set_phase_noise(struct nim_device *dev)
 		nim_reg_write(dev, RB5_CR_PRS_TRA, &sdat, 1);
 	}
 
+_DEBUG
 	printk("--------------------EXIT set_phase_noise, REG_b5 = 0x%x\n", sdat);
 
 	data = 0x10;
@@ -2028,6 +2041,7 @@ static INT32 nim_s3501_waiting_channel_lock(/*TUNER_ScanTaskParam_T *Inst,*/
 		}
 
 		nim_reg_read(dev, R02_IERR, &intdata, 1);
+_DEBUG
         printk("###########R02_IERR intdata = 0x%x\n", intdata);
 		//intdata |= 0x02;
 		data = 0x02;
@@ -2060,6 +2074,7 @@ static INT32 nim_s3501_waiting_channel_lock(/*TUNER_ScanTaskParam_T *Inst,*/
 			}
 			else
 			{
+_DEBUG
 				printk("        lock chanel \n");
                 //printk("[%dms]\n",YWOS_TimeNow()-TuneStartTime);
 
@@ -3186,6 +3201,7 @@ static INT32 nim_s3501_dynamic_power(struct nim_device *dev, UINT8 snr)
 
 	if (cur_max_iter != last_max_iter)
 	{
+_DEBUG
 		printk("----change cur_max_iter to %d----\n\n", cur_max_iter);
 		nim_reg_write(dev, R57_LDPC_CTRL, &cur_max_iter, 1);
 		last_max_iter = cur_max_iter;
@@ -3362,10 +3378,13 @@ static INT32 nim_s3501_reg_get_map_type(struct nim_device *dev, UINT8 *map_type)
 static INT32 nim_s3501_reg_get_work_mode(struct nim_device *dev, UINT8 *work_mode)
 {
 	UINT8 data;
+_DEBUG
 	 printk("Enter Fuction nim_s3501_reg_get_work_mode \n");
 	nim_reg_read(dev, R68_WORK_MODE, &data, 1);
+_DEBUG
 	printk("nim_s3501_reg_get_work_mode data = 0x%x\n",data);
 	*work_mode = data & 0x03;
+_DEBUG
     printk("*$$$$$$$$$$$$$$$$$$work_mode = %d\n",*work_mode);
 	return SUCCESS;
 
@@ -3416,6 +3435,7 @@ INT32 nim_s3501_reg_get_symbol_rate(struct nim_device *dev, UINT32 *sym_rate)
 	temp = temp | (data[0] & 0xff);
 	symrate = temp;
 
+_DEBUG
 	printk("symrate ==== 0x%x\n",symrate);
 	symrate = (UINT32) ((temp * 1000) / 2048);
 	if (priv->ul_status.m_s3501_type == NIM_CHIP_ID_M3501B)
@@ -3425,6 +3445,7 @@ INT32 nim_s3501_reg_get_symbol_rate(struct nim_device *dev, UINT32 *sym_rate)
 
 
 	*sym_rate = symrate;
+_DEBUG
 	printk (" *sym_rate is 0x%x\n", *sym_rate );
 	return SUCCESS;
 }
@@ -3443,6 +3464,7 @@ void nim_s3501_set_RS(struct nim_device *dev, UINT32 rs)
 	if (priv->ul_status.m_s3501_type == NIM_CHIP_ID_M3501B)
 	{
 
+_DEBUG
 		printk("nim_s3501_set_RS NIM_CHIP_ID_M3501B \n");
 		rs = rs / (CRYSTAL_FREQ * 90 / 135) * 90;
 	}
@@ -3457,30 +3479,37 @@ void nim_s3501_set_RS(struct nim_device *dev, UINT32 rs)
 	data = (UINT8) (rs & 0xFF);
 
     nim_reg_read(dev,RA3_CHIP_ID + 0x01, &ver_data, 1);
+_DEBUG
     printk("1111111ooooooooooooo ver_data = 0x%x\n", ver_data);
 
     nim_reg_read(dev,R5F_ACQ_SYM_RATE, &ver_data, 1);
+_DEBUG
     printk("1111111ooooooooooooo ver_data = 0x%x\n", ver_data);
 
     nim_reg_write(dev, R5F_ACQ_SYM_RATE, &data, 1);
 	nim_reg_read(dev, R5F_ACQ_SYM_RATE, &ver_data, 1);
 	if (data != ver_data)
 	{
+_DEBUG
 		printk("wrong 0x5f reg write\n");
 	}
+_DEBUG
     printk("nim_s3501_set_RS CR3F rs = 0x%x, ver_data = 0x%x\n",data, ver_data);
 
 	//CR40
 	data = (UINT8) ((rs & 0xFF00) >> 8);
     nim_reg_read(dev,R5F_ACQ_SYM_RATE+1, &ver_data, 1);
+_DEBUG
     printk("2222222ooooooooooooo ver_data = 0x%x\n", ver_data);
 
 	nim_reg_write(dev, R5F_ACQ_SYM_RATE + 0x01, &data, 1);
 	nim_reg_read(dev, R5F_ACQ_SYM_RATE + 0x01, &ver_data, 1);
 	if (data != ver_data)
 	{
+_DEBUG
 		printk("wrong 0x60 reg write\n");
 	}
+_DEBUG
     printk("nim_s3501_set_RS CR40 rs = 0x%x, ver_data = 0x%x\n",data, ver_data);
 
 	//CR41
@@ -3489,8 +3518,10 @@ void nim_s3501_set_RS(struct nim_device *dev, UINT32 rs)
 	nim_reg_read(dev, R5F_ACQ_SYM_RATE + 0x02, &ver_data, 1);
 	if (data != ver_data)
 	{
+_DEBUG
 		printk("wrong 0x61 reg write\n");
 	}
+_DEBUG
     printk("nim_s3501_set_RS CR41 rs = 0x%x, ver_data = 0x%x\n",data, ver_data);
 
 }
@@ -3514,6 +3545,7 @@ void nim_s3501_set_freq_offset(struct nim_device *dev, INT32 delfreq)
 	nim_reg_read(dev, R5C_ACQ_CARRIER, &ver_data, 1);
 	if (data != ver_data)
 	{
+_DEBUG
 		printk(" wrong 0x5c reg write\n");
 	}
 	//CR5D
@@ -3522,6 +3554,7 @@ void nim_s3501_set_freq_offset(struct nim_device *dev, INT32 delfreq)
 	nim_reg_read(dev, R5C_ACQ_CARRIER + 0x01, &ver_data, 1);
 	if (data != ver_data)
 	{
+_DEBUG
 		printk(" wrong 0x5d reg write\n");
 	}
 
@@ -3532,6 +3565,7 @@ void nim_s3501_set_freq_offset(struct nim_device *dev, INT32 delfreq)
 	nim_reg_read(dev, R5C_ACQ_CARRIER + 0x02, &ver_data, 1);
 	if (data != ver_data)
 	{
+_DEBUG
 		printk(" wrong 0x5e reg write\n");
 	}
 
@@ -3631,6 +3665,7 @@ static INT32 nim_s3501_get_type(struct nim_device *dev)
 	m_Value = (m_Value << 8) | temp[0];
 	m_Value = (m_Value << 8) | temp[3];
 	m_Value = (m_Value << 8) | temp[2];
+_DEBUG
     printk("############nim_s3501_get_type    temp = 0x%x, m_Value = 0x%x\n",
 			(int)temp, (int)m_Value);
 	//priv->ul_status.m_s3501_type = m_Value; //lwj remove
@@ -3756,6 +3791,7 @@ static INT32 nim_s3501_adc_setting(struct nim_device *dev)
 	nim_reg_read(dev, R01_ADC, &ver_data, 1);
 	if (data != ver_data)
 	{
+_DEBUG
 		printk(" 11111111111 wrong 0x8 reg write\n");
 		return ERR_FAILED;
 	}
@@ -4085,10 +4121,12 @@ static INT32 nim_s3501_set_acq_workmode(struct nim_device *dev, UINT8 s_Case)
 		nim_reg_write(dev, R5B_ACQ_WORK_MODE, &data, 1);
 		break;
 	case NIM_OPTR_CHL_CHANGE:
+_DEBUG
 		printk("####nim_s3501_set_acq_workmode NIM_OPTR_CHL_CHANGE \n");
 		nim_s3501_reg_get_work_mode(dev, &work_mode);
 		if (work_mode != M3501_DVBS2_MODE)// not in DVBS2 mode, key word: power_ctrl
 		{
+_DEBUG
             printk("DVBS1===================\n");
 			if (priv->ul_status.m_s3501_type == NIM_CHIP_ID_M3501B)
 				priv->ul_status.phase_err_check_status = 1000;
@@ -4155,6 +4193,7 @@ static INT32 nim_s3501_set_FC_Search_Range(struct nim_device *dev, UINT8 s_Case,
 			nim_reg_read(dev, R62_FC_SEARCH, &ver_data, 1);
 			if (data != ver_data)
 			{
+_DEBUG
 				printk(" wrong 0x62 reg write\n");
 			}
 			//CR63
@@ -4169,6 +4208,7 @@ static INT32 nim_s3501_set_FC_Search_Range(struct nim_device *dev, UINT8 s_Case,
 			nim_reg_read(dev, R62_FC_SEARCH + 0x01, &ver_data, 1);
 			if (data != ver_data)
 			{
+_DEBUG
 				printk(" wrong 0x63 reg write\n");
 			}
 			priv->t_Param.t_reg_setting_switch |= NIM_SWITCH_FC;
@@ -4227,6 +4267,7 @@ static INT32 nim_s3501_RS_Search_Range(struct nim_device *dev, UINT8 s_Case, UIN
 			nim_reg_read(dev, R64_RS_SEARCH, &ver_data, 1);
 			if (data != ver_data)
 			{
+_DEBUG
 				printk(" wrong 0x64 reg write\n");
 			}
 			//CR65
@@ -4242,6 +4283,7 @@ static INT32 nim_s3501_RS_Search_Range(struct nim_device *dev, UINT8 s_Case, UIN
 			nim_reg_read(dev, R64_RS_SEARCH + 0x01, &ver_data, 1);
 			if (data != ver_data)
 			{
+_DEBUG
 				printk(" wrong 0x65 reg write\n");
 			}
 			priv->t_Param.t_reg_setting_switch |= NIM_SWITCH_RS;
@@ -4486,6 +4528,7 @@ static int d3501_read_snr(struct dvb_frontend* fe, u16* snr)
 	if(*snr > 90)
 		*snr = 90;
 	*snr = *snr * 255 * 255 / 100;
+_DEBUG
 	printk("*snr = %d\n", *snr);
 	return iRet;
 }
@@ -4515,6 +4558,7 @@ static int d3501_read_signal_strength(struct dvb_frontend* fe,
 #endif // 0
 	*Intensity = *Intensity * 255 * 255 / 100;
 	*strength = *Intensity;
+_DEBUG
 	printk("*strength = %d\n", *strength);
 	return iRet;
 }
@@ -4553,10 +4597,13 @@ static int d3501_read_status(struct dvb_frontend *fe, enum fe_status *status)
 	{
 		if (fe->ops.tuner_ops.get_status(fe, &iTunerLock) < 0)
 		{
+_DEBUG
 			printk("1. Tuner get_status err\n");
 		}
 	}
 
+_DEBUG
+{
 	if (iTunerLock)
 	{
 		#if defined(NIM_S3501_DEBUG)
@@ -4567,7 +4614,7 @@ static int d3501_read_status(struct dvb_frontend *fe, enum fe_status *status)
 	{
 		printk("1. Tuner unlocked\n");
 	}
-
+}
 
 	if (nim_s3501_i2c_close(&state->spark_nimdev))
 		return S3501_ERR_I2C_NO_ACK;
@@ -4605,8 +4652,11 @@ static int d3501_set_tuner_params(struct dvb_frontend *fe,
 	param.frequency = freq;
 	param.u.qpsk.symbol_rate = sym;
 
+_DEBUG
+{
 	printk("param.frequency = %d\n", param.frequency);
 	printk("param.u.qpsk.symbol_rate = %d\n", param.u.qpsk.symbol_rate);
+}
 
 	if (!tuner_ops->set_params)
 	{
@@ -4616,6 +4666,7 @@ static int d3501_set_tuner_params(struct dvb_frontend *fe,
 	err = tuner_ops->set_params(fe, &param);
 	if (err < 0)
 	{
+_DEBUG
 		printk("%s: Invalid parameter\n", __func__);
 		return -1;
 	}
@@ -4648,6 +4699,7 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
     dev = (struct nim_device *)&state->spark_nimdev;
 	priv = (struct nim_s3501_private *) dev->priv;
 
+_DEBUG
 	printk("p->frequency is %d\n", p->frequency);
 
     priv->bLock = FALSE;
@@ -4661,8 +4713,11 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 
 	//starttime = 0;
 	////printk("    Enter Fuction nim_s3501_channel_change \n");
+_DEBUG
+{
 	printk("    freq is %d\n", freq);
 	printk("    sym is %d\n", sym);
+}
 	//printk("    fec is %d\n", fec);
 
 	priv->t_Param.t_phase_noise_detected = 0;
@@ -4688,6 +4743,7 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 #endif*/  //lwj remove
 	if (priv->ul_status.m_s3501_type == NIM_CHIP_ID_M3501B)
 	{
+_DEBUG
 		printk("NIM_CHIP_ID_M3501B ########### d3501_Search\n");
 		priv->ul_status.phase_err_check_status = 0;
 		priv->ul_status.s3501d_lock_status = NIM_LOCK_STUS_NORMAL;
@@ -4696,16 +4752,20 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 	priv->ul_status.m_setting_freq = freq;
 
 	//reset first
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_demod_ctrl(dev, NIM_DEMOD_CTRL_0X91);
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	msleep(5); //sleep 5ms lwj add
 
 	if ((0 == freq) || (0 == sym))
 		return DVBFE_ALGO_SEARCH_ERROR;
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_sym_config(dev, sym);
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 
 #if 1
@@ -4723,20 +4783,27 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 
 	// time for channel change and sof search.
 	// ttt
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_TR_CR_Setting(dev, NIM_OPTR_CHL_CHANGE);
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 
 	low_sym = sym < 6500 ? 1 : 0;   /* Symbol rate is less than 10M, low symbol rate */
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_freq_offset_set(dev, low_sym, &freq);
+_DEBUG
+{
 	printk("[%s][%d]freq = %d\n", __FUNCTION__, __LINE__, freq);
 
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
+}
 	if (nim_s3501_i2c_open(dev))
 		return DVBFE_ALGO_SEARCH_FAILED;
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	err = d3501_set_tuner_params(fe, freq, sym);
 	if (err < 0)
@@ -4744,12 +4811,14 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 		return DVBFE_ALGO_SEARCH_FAILED;
 	}
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	if (nim_s3501_i2c_close(dev))
 		return DVBFE_ALGO_SEARCH_FAILED;
 
 	msleep(1);
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	if (nim_s3501_i2c_open(dev))
 		return DVBFE_ALGO_SEARCH_FAILED;
@@ -4758,14 +4827,17 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 	{
 		int iTunerLock;
 
+_DEBUG
 		printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 		if (fe->ops.tuner_ops.get_status(fe, &iTunerLock) < 0)
 		{
+_DEBUG
 			printk("1. Tuner get_status err\n");
 		}
 	}
 
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	if (nim_s3501_i2c_close(dev))
 		return DVBFE_ALGO_SEARCH_FAILED;
@@ -4774,13 +4846,16 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 
 	data = 0x10;
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_reg_write(dev,RB3_PIN_SHARE_CTRL, &data, 1);
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_adc_setting(dev);
 
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_interrupt_mask_clean(dev);
 
@@ -4789,6 +4864,7 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 	//    data = 0xff;
 	//    nim_reg_write(dev,R05_TIMEOUT_TRH, &data, 1);
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_set_hw_timeout(dev, 0xff);
 	//    data = 0x1f; // setting for soft search function
@@ -4796,11 +4872,13 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 
 	// AGC1 setting
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_agc1_ctrl(dev, low_sym, NIM_OPTR_CHL_CHANGE);
 
 	// Set symbol rate
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_set_RS(dev, sym);
 
@@ -4808,17 +4886,20 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 	{
 		// Only for M3501B
 
+_DEBUG
 		printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 		nim_set_ts_rs(dev, sym);
 	}
 
 	// Set carry offset
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_freq_offset_reset(dev, low_sym);
 
 	// ttt
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_cr_setting(dev, NIM_OPTR_CHL_CHANGE);
 
@@ -4831,22 +4912,26 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 
 	// ttt
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_set_acq_workmode(dev, NIM_OPTR_CHL_CHANGE0);
 
 	// set sweep range
 	// ttt
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_set_FC_Search_Range(dev, NIM_OPTR_CHL_CHANGE, 0x00);
 	// ttt
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_RS_Search_Range(dev, NIM_OPTR_CHL_CHANGE, 0x00);
 
 	// ttt
 	// LDPC parameter
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_ldpc_setting(dev, NIM_OPTR_CHL_CHANGE, 0x00, 0x01);
 
@@ -4869,6 +4954,7 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 	// Carcy disable HBCD check, let time out. 2008-03-12
 	// ttt
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_hbcd_timeout(dev, NIM_OPTR_CHL_CHANGE);
 
@@ -4916,6 +5002,7 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 	}
 
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_demod_ctrl(dev, NIM_DEMOD_CTRL_0X51);
     ////printk("1111111[%dms]\n", YWOS_TimeNow() - TuneStartTime);
@@ -4965,6 +5052,7 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
     dev = (struct nim_device *)&state->spark_nimdev;
 	priv = (struct nim_s3501_private *) dev->priv;
 
+_DEBUG
 	printk("p->frequency is %d\n", p->frequency);
 
     priv->bLock = FALSE;
@@ -4978,8 +5066,11 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 
 	//starttime = 0;
 	////printk("    Enter Fuction nim_s3501_channel_change \n");
+_DEBUG
+{
 	printk("    freq is %d\n", freq);
 	printk("    sym is %d\n", sym);
+}
 	//printk("    fec is %d\n", fec);
 
 	priv->t_Param.t_phase_noise_detected = 0;
@@ -5005,6 +5096,7 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 #endif*/  //lwj remove
 	if (priv->ul_status.m_s3501_type == NIM_CHIP_ID_M3501B)
 	{
+_DEBUG
 		printk("NIM_CHIP_ID_M3501B ########### d3501_Search\n");
 		priv->ul_status.phase_err_check_status = 0;
 		priv->ul_status.s3501d_lock_status = NIM_LOCK_STUS_NORMAL;
@@ -5013,16 +5105,20 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 	priv->ul_status.m_setting_freq = freq;
 
 	//reset first
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_demod_ctrl(dev, NIM_DEMOD_CTRL_0X91);
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	msleep(5); //sleep 5ms lwj add
 
 	if ((0 == freq) || (0 == sym))
 		return DVBFE_ALGO_SEARCH_ERROR;
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_sym_config(dev, sym);
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 
 #if 1
@@ -5040,20 +5136,27 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 
 	// time for channel change and sof search.
 	// ttt
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_TR_CR_Setting(dev, NIM_OPTR_CHL_CHANGE);
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 
 	low_sym = sym < 6500 ? 1 : 0;   /* Symbol rate is less than 10M, low symbol rate */
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_freq_offset_set(dev, low_sym, &freq);
+_DEBUG
+{
 	printk("[%s][%d]freq = %d\n", __FUNCTION__, __LINE__, freq);
 
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
+}
 	if (nim_s3501_i2c_open(dev))
 		return DVBFE_ALGO_SEARCH_FAILED;
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	err = d3501_set_tuner_params(fe, freq, sym);
 	if (err < 0)
@@ -5061,12 +5164,14 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 		return DVBFE_ALGO_SEARCH_FAILED;
 	}
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	if (nim_s3501_i2c_close(dev))
 		return DVBFE_ALGO_SEARCH_FAILED;
 
 	msleep(1);
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	if (nim_s3501_i2c_open(dev))
 		return DVBFE_ALGO_SEARCH_FAILED;
@@ -5075,14 +5180,17 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 	{
 		int iTunerLock;
 
+_DEBUG
 		printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 		if (fe->ops.tuner_ops.get_status(fe, &iTunerLock) < 0)
 		{
+_DEBUG
 			printk("1. Tuner get_status err\n");
 		}
 	}
 
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	if (nim_s3501_i2c_close(dev))
 		return DVBFE_ALGO_SEARCH_FAILED;
@@ -5091,13 +5199,16 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 
 	data = 0x10;
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_reg_write(dev,RB3_PIN_SHARE_CTRL, &data, 1);
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_adc_setting(dev);
 
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_interrupt_mask_clean(dev);
 
@@ -5106,6 +5217,7 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 	//    data = 0xff;
 	//    nim_reg_write(dev,R05_TIMEOUT_TRH, &data, 1);
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_set_hw_timeout(dev, 0xff);
 	//    data = 0x1f; // setting for soft search function
@@ -5113,11 +5225,13 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 
 	// AGC1 setting
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_agc1_ctrl(dev, low_sym, NIM_OPTR_CHL_CHANGE);
 
 	// Set symbol rate
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_set_RS(dev, sym);
 
@@ -5125,17 +5239,20 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 	{
 		// Only for M3501B
 
+_DEBUG
 		printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 		nim_set_ts_rs(dev, sym);
 	}
 
 	// Set carry offset
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_freq_offset_reset(dev, low_sym);
 
 	// ttt
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_cr_setting(dev, NIM_OPTR_CHL_CHANGE);
 
@@ -5148,22 +5265,26 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 
 	// ttt
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_set_acq_workmode(dev, NIM_OPTR_CHL_CHANGE0);
 
 	// set sweep range
 	// ttt
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_set_FC_Search_Range(dev, NIM_OPTR_CHL_CHANGE, 0x00);
 	// ttt
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_RS_Search_Range(dev, NIM_OPTR_CHL_CHANGE, 0x00);
 
 	// ttt
 	// LDPC parameter
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_ldpc_setting(dev, NIM_OPTR_CHL_CHANGE, 0x00, 0x01);
 
@@ -5186,6 +5307,7 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 	// Carcy disable HBCD check, let time out. 2008-03-12
 	// ttt
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_hbcd_timeout(dev, NIM_OPTR_CHL_CHANGE);
 
@@ -5233,6 +5355,7 @@ static enum dvbfe_search d3501_Search(struct dvb_frontend *fe,
 	}
 
 
+_DEBUG
 	printk("[%s][%d]\n", __FUNCTION__, __LINE__);
 	nim_s3501_demod_ctrl(dev, NIM_DEMOD_CTRL_0X51);
     ////printk("1111111[%dms]\n", YWOS_TimeNow() - TuneStartTime);
@@ -5331,6 +5454,7 @@ static int d3501_set_tone(struct dvb_frontend* fe, fe_sec_tone_mode_t tone)
 
 	nim_reg_write(dev, R7C_DISEQC_CTRL + 0x14, &data, 1);
 
+_DEBUG
     printk("tone = %d\n", tone);
 
 	if (tone == SEC_TONE_ON)				/* Low band -> no 22KHz tone */
@@ -5355,11 +5479,13 @@ static int d3501_set_voltage(struct dvb_frontend* fe, fe_sec_voltage_t voltage)
     switch (voltage)
     {
         case SEC_VOLTAGE_OFF:
+_DEBUG
             printk("set_voltage_off\n");
             stpio_set_pin(state->fe_lnb_on_off, 0);
             break;
 
         case SEC_VOLTAGE_13: /* vertical */
+_DEBUG
             printk("set_voltage_vertical \n");
             stpio_set_pin(state->fe_lnb_on_off, 1);
             msleep(1);
@@ -5369,6 +5495,7 @@ static int d3501_set_voltage(struct dvb_frontend* fe, fe_sec_voltage_t voltage)
             break;
 
         case SEC_VOLTAGE_18: /* horizontal */
+_DEBUG
             printk("set_voltage_horizontal\n");
             stpio_set_pin(state->fe_lnb_on_off, 1);
             msleep(1);
@@ -5534,6 +5661,7 @@ static int d3501_initition(struct nim_device *dev, struct i2c_adapter	*i2c)
 		return -1;
 	}
 
+_DEBUG
 	printk("priv_mem->i2c_adap = %0x\n", (int)priv_mem->i2c_adap);
 
     //priv_mem->tuner_id = Handle; //lwj add important
diff --git a/frontends/spark7162/spark7162.c b/frontends/spark7162/spark7162.c
index 5ed9876..54bec0c 100644
--- a/frontends/spark7162/spark7162.c
+++ b/frontends/spark7162/spark7162.c
@@ -102,6 +102,7 @@ enum
 
 static int eUnionTunerType = UNION_TUNER_T;
 static char *UnionTunerType = "t";
+int debug_fe7162 = 0;
 
 /*******************************  数据结构*********************************/
 
@@ -906,6 +907,9 @@ module_exit(spark_cleanup);
 module_param(UnionTunerType, charp, 0);
 MODULE_PARM_DESC(UnionTunerType, "Union Tuner Type (t, c)");
 
+module_param(debug_fe7162, int, 0);
+MODULE_PARM_DESC(debug_fe7162, "debug (very noisy!), default 0");
+
 /* EOF------------------------------------------------------------------------*/
 
 /* BOL-------------------------------------------------------------------*/
diff --git a/frontends/spark7162/stv0367/D0367cab.c b/frontends/spark7162/stv0367/D0367cab.c
index ffdd611..cd024b7 100644
--- a/frontends/spark7162/stv0367/D0367cab.c
+++ b/frontends/spark7162/stv0367/D0367cab.c
@@ -23,6 +23,9 @@
 #include "dvb_frontend.h"
 #include "D0367.h"
 
+extern int debug_fe7162;
+#define _DEBUG if (debug_fe7162)
+
 struct dvb_d0367_fe_qam_state {
 	struct i2c_adapter			*i2c;
 	struct dvb_frontend 		frontend;
@@ -119,6 +122,7 @@ static int dvb_d0367_fe_qam_set_frontend(struct dvb_frontend* fe,
 	{
 		BOOL bIsLocked;
 		bIsLocked = FE_367qam_Status(&state->DeviceMap, state->IOHandle);
+_DEBUG
 		printk("%d:bIsLocked = %d\n", __LINE__, bIsLocked);
     }
 
@@ -168,6 +172,7 @@ static int dvb_d0367_fe_qam_read_status(struct dvb_frontend* fe,
 	#endif  /* 0 */
 	{
 		bIsLocked = FE_367qam_Status(&state->DeviceMap, state->IOHandle);
+_DEBUG
 		printk("bIsLocked = %d\n", bIsLocked);
     }
 	if (bIsLocked)
@@ -190,6 +195,7 @@ static int dvb_d0367_fe_qam_read_status(struct dvb_frontend* fe,
 
 	    FE_STV0367qam_GetSignalInfo(&state->DeviceMap, state->IOHandle,
 	                                &Quality, &Intensity, &Ber,  FirstTimeBER);
+_DEBUG
 	    printk("Quality = %d, Intensity = %d, Ber = %d\n",
 	    		Quality, Intensity, Ber);
 	}
@@ -337,6 +343,7 @@ U32	D0367qam_GeSymbolRate(TUNER_IOREG_DeviceMap_t *DeviceMap,
 	    return SymbolRate;
 	}
 
+_DEBUG
 	printk("p->u.qam.symbol_rate = %d\n", p->u.qam.symbol_rate);
 	SymbolRate = p->u.qam.symbol_rate;
 
@@ -731,11 +738,14 @@ YW_ErrorType_T D0367qam_ScanFreq(TUNER_IOREG_DeviceMap_t *DemodDeviceMap,
     pParams.Frequency_kHz  = D0367qam_GeFrequencyKhz(DeviceMap, IOHandle);////
     pParams.AdcClock_Hz    = FE_367qam_GetADCFreq(DeviceMap,IOHandle,pParams.Crystal_Hz);
     pParams.MasterClock_Hz = FE_367qam_GetMclkFreq(DeviceMap,IOHandle,pParams.Crystal_Hz);
+_DEBUG
+{
 	printk("demod_d0367qam_ScanFreq  Frequency === %d\n", pParams.Frequency_kHz);
 	printk("demod_d0367qam_ScanFreq  Modulation === %d\n", pParams.Modulation);
 	printk("SymbolRate_Bds  =========== %d\n", pParams.SymbolRate_Bds);
 //    printk("pParams.AdcClock_Hz  ====== %d\n",pParams.AdcClock_Hz);
 //    printk("pParams.MasterClock_Hz ===== %d\n",pParams.MasterClock_Hz);
+}
 
     #if 0
     if (Inst->DriverParam.Cab.TunerDriver.tuner_SetFreq != NULL)
@@ -781,6 +791,7 @@ YW_ErrorType_T D0367qam_ScanFreq(TUNER_IOREG_DeviceMap_t *DemodDeviceMap,
 	if( (pParams.State == FE_367qam_DATAOK) && (!Error))
 	{
 		/* update results */
+_DEBUG
         printk("TUNER_STATUS_LOCKED #######################\n");
 	    //Inst->Status = TUNER_STATUS_LOCKED;
 		//pResult->Frequency_kHz = pIntParams->DemodResult.Frequency_kHz;
@@ -790,6 +801,7 @@ YW_ErrorType_T D0367qam_ScanFreq(TUNER_IOREG_DeviceMap_t *DemodDeviceMap,
 	}
 	else
 	{
+_DEBUG
         printk("TUNER_STATUS_UNLOCKED #######################\n");
 		//Inst->Status = TUNER_STATUS_UNLOCKED;
 	}
@@ -832,6 +844,7 @@ struct dvb_frontend* dvb_d0367_fe_qam_attach(struct i2c_adapter* i2c)
 {
     U8 data = 0xFF;
     data = ChipGetField_0367qam(DeviceMap, IOHandle, R367qam_ID);
+_DEBUG
 	printk("set data = 0x%02x\n", data);
 }
 
diff --git a/frontends/spark7162/stv0367/D0367ter.c b/frontends/spark7162/stv0367/D0367ter.c
index e1972a6..54aa883 100644
--- a/frontends/spark7162/stv0367/D0367ter.c
+++ b/frontends/spark7162/stv0367/D0367ter.c
@@ -23,6 +23,9 @@
 #include "dvb_frontend.h"
 #include "D0367.h"
 
+extern int debug_fe7162;
+#define _DEBUG if (debug_fe7162)
+
 struct dvb_d0367_fe_ofdm_state {
 	struct i2c_adapter			*i2c;
 	struct dvb_frontend 		frontend;
@@ -140,6 +143,7 @@ static int dvb_d0367_fe_ofdm_read_status(struct dvb_frontend* fe,
 	#endif  /* 0 */
 	{
 		bIsLocked = FE_367ofdm_lock(&state->DeviceMap, state->IOHandle);
+_DEBUG
 		printk("bIsLocked = %d\n", bIsLocked);
     }
 	if (bIsLocked)
@@ -768,8 +772,11 @@ YW_ErrorType_T D0367ter_ScanFreq(TUNER_IOREG_DeviceMap_t *DeviceMap,
    // printk("demod_d0367ter_ScanFreq #########Index = %d\n", Index);
 	pParams.Frequency = D0367ter_GeFrequency(DeviceMap, IOHandle);
 	pParams.ChannelBW = D0367ter_GeChannelBW(DeviceMap, IOHandle);
+_DEBUG
+{
 	printk("pParams.Frequency = %d\n", pParams.Frequency);
 	printk("pParams.ChannelBW = %d\n", pParams.ChannelBW);
+}
 	pParams.Crystal_Hz = DeviceMap->RegExtClk;
 	pParams.IF_IQ_Mode = FE_TER_NORMAL_IF_TUNER;//FE_TER_IQ_TUNER;	//most tuner is IF mode, stv4100 is I/Q mode
 	pParams.Inv 	   = FE_TER_INVERSION_AUTO; //FE_TER_INVERSION_AUTO
diff --git a/frontends/spark7162/stv0367/stv0367qam/chip_0367qam.c b/frontends/spark7162/stv0367/stv0367qam/chip_0367qam.c
index e048096..d626c03 100644
--- a/frontends/spark7162/stv0367/stv0367qam/chip_0367qam.c
+++ b/frontends/spark7162/stv0367/stv0367qam/chip_0367qam.c
@@ -36,6 +36,9 @@
 
 extern IOARCH_HandleData_t IOARCH_Handle[TUNER_IOARCH_MAX_HANDLES];
 
+extern int debug_fe7162;
+#define _DEBUG if (debug_fe7162)
+
 #define REPEATER_ON    1
 #define REPEATER_OFF   0
 #define WAITFORLOCK    1
@@ -231,6 +234,7 @@ YW_ErrorType_T  ChipSetRegisters_0367qam(TUNER_IOREG_DeviceMap_t *DeviceMap, IOA
 	else
 		return YWHAL_ERROR_INVALID_HANDLE;
    
+_DEBUG
 	if (DeviceMap->Error != 0)
 	{
         printk("d0367ter DeviceMap->Error=%d,FirstRegAddr=%x\n",DeviceMap->Error,FirstRegAddr);//for test
@@ -291,6 +295,7 @@ YW_ErrorType_T ChipSetField_0367qam(TUNER_IOREG_DeviceMap_t *DeviceMap, IOARCH_H
 	else
 		return YWHAL_ERROR_INVALID_HANDLE;
 
+_DEBUG
     if (DeviceMap->Error != 0)
 	{
          printk("d0376ter chip.c DeviceMap->Error=%d,FirstRegAddr=%x\n",DeviceMap->Error,FieldId);//for test
diff --git a/frontends/spark7162/stv0367/stv0367qam/d0367_qam.c b/frontends/spark7162/stv0367/stv0367qam/d0367_qam.c
index f686866..ff91bbb 100644
--- a/frontends/spark7162/stv0367/stv0367qam/d0367_qam.c
+++ b/frontends/spark7162/stv0367/stv0367qam/d0367_qam.c
@@ -39,6 +39,8 @@
 #include "stv0367qam_drv.h"
 #include "d0367_qam.h"
 
+extern int debug_fe7162;
+#define _DEBUG if (debug_fe7162)
 
 STCHIP_Register_t Def367qamVal[STV0367qam_NBREGS]=
 {
@@ -252,11 +254,13 @@ YW_ErrorType_T  demod_d0367qam_Identify(IOARCH_Handle_t   IOHandle, U8  ucID, U8
     //if (TUNER_IOARCH_ReadWrite(IOHandle, TUNER_IO_SA_READ, R367qam_ID, pucActualID, 1, 50) == YW_NO_ERROR)
 	if (YW_NO_ERROR == YW_NO_ERROR)
 	{
+_DEBUG
         printk("demod_d0367qam_Identify pucActualID = 0x%x\n", *pucActualID);//question
     	return YW_NO_ERROR;
     }
     else
     {
+_DEBUG
         printk("demod_d0367qam_Identify YWHAL_ERROR_UNKNOWN_DEVICE \n");//question
     	return YWHAL_ERROR_UNKNOWN_DEVICE;
     }
diff --git a/frontends/spark7162/stv0367/stv0367ter/chip_0367ter.c b/frontends/spark7162/stv0367/stv0367ter/chip_0367ter.c
index a794803..d7e1d93 100644
--- a/frontends/spark7162/stv0367/stv0367ter/chip_0367ter.c
+++ b/frontends/spark7162/stv0367/stv0367ter/chip_0367ter.c
@@ -36,6 +36,9 @@
 
 extern IOARCH_HandleData_t IOARCH_Handle[TUNER_IOARCH_MAX_HANDLES];
 
+extern int debug_fe7162;
+#define _DEBUG if (debug_fe7162)
+
 #define REPEATER_ON    1
 #define REPEATER_OFF   0
 #define WAITFORLOCK    1
@@ -236,6 +239,7 @@ YW_ErrorType_T  ChipSetRegisters_0367ter(TUNER_IOREG_DeviceMap_t *DeviceMap, IOA
 	else
 		return YWHAL_ERROR_INVALID_HANDLE;
 
+_DEBUG
 	if (DeviceMap->Error != 0)
 	{
         printk("d0367ter DeviceMap->Error=%d,FirstRegAddr=%x\n",DeviceMap->Error,FirstRegAddr);//for test
@@ -301,6 +305,7 @@ YW_ErrorType_T
 	else
 		return YWHAL_ERROR_INVALID_HANDLE;
 
+_DEBUG
     if (DeviceMap->Error != 0)
 	{
          printk("d0376ter chip.c DeviceMap->Error=%d,FirstRegAddr=%x\n",DeviceMap->Error,FieldId);//for test
-- 
1.7.10.4

